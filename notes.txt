Circular
  Let's say there are 4 codes to find.
  Code 3 is scanned first. Clues for code 4 are provided.
  The order of the game will be 3,4,2,1
  When all codes have been found the game is complete.

Random
  This is intended for smaller spaces.
  The order of the clues is completely random.
  When all codes have been found the game is complete.

Linear
  The first code in this game set always points to the starting point.
  It does not matter which code is scanned.
  If the starting point has not been located, the clues will always lead to the start point.
  The game then continues in sequential order.
  If code 2 was scanned first, it will lead to the starting point at Code 1.
  The order of the game will be 2,1,2,3,4
  When the all codes have been found in sequential order, the game is complete.


Make people work for the coordinates


console.log(req.params.key);
if (req.params.key.length > 15){
  console.log('go');
  data_key = urlCrypt.decryptObj(req.params.key)
  console.log(data_key);
}
else


app.get('/:key', function (req, res) {
  var client = redis.createClient(process.env.REDIS_URL)
  var key_string = req.params.key.replace(/code:/g,'')
  var page_url = req.protocol + '://' + req.get('host') + '/' + key_string;
  var qr_url= req.protocol + '://' + req.get('host') + '/code:';
  console.log(req.params.key);
  if (req.params.key.slice(0,5) == 'code:') {





//this section creates QR codes when a code: URL is passed
 //may want to consider adding logic here to create codes only if items exist in JSON file

    var code = qr.image(page_url, { type: 'svg' })
    res.type('svg');
    code.pipe(res);

  } else {
//this section creates pages from template.pug based on the URL key
    client.hget(req.clientIp, req.params.key, function(err, usr_pg_view){

        jsonfile.readFile( "data.json", 'utf8', function (err, data) {
          var pg_json_record = {}
            for (var i = 0; i < data.length; i++) {
                if (data[i].key == req.params.key){
                  pg_json_record = data[i]
                };
            };
          res.render('template', {
              qr_code: qr_url,
              json_data: data,
              previous_view: usr_pg_view,
              request: req.params.key,
              pg_json_record: pg_json_record
          });
        });
    });
  }
  //console.log('Cookies: ', req.cookies)
  client.hset(req.clientIp, req.params.key, Date())
  client.quit()
});
